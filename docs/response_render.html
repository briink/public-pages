<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Briink EQA Custom Renderer</title>
        <script src="https://cdn.jsdelivr.net/npm/renderjson@1.4.0/renderjson.min.js"></script>
        <style>
            :root {
                --bg-color: #1a1d21;
                --card-bg: #22262b;
                --text-color: #e8eaed;
                --text-muted: #9aa0a6;
                --border-color: #3c4043;
                --accent-color: #8ab4f8;
                --success-color: #81c995;
                --warning-color: #fdd663;
                --error-color: #f28b82;
                --diff-added-bg: rgba(129, 201, 149, 0.15);
                --diff-removed-bg: rgba(242, 139, 130, 0.15);
                --diff-added-text: #81c995;
                --diff-removed-text: #f28b82;
            }

            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    "Helvetica Neue", Arial, sans-serif;
                background-color: var(--bg-color);
                color: var(--text-color);
                padding: 16px;
                line-height: 1.5;
            }

            .container {
                display: flex;
                flex-direction: column;
                gap: 24px;
                width: 100%;
                max-width: 100%;
            }

            .panel {
                background-color: var(--card-bg);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                overflow: hidden;
            }

            .panel-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px 16px;
                background-color: #2d3136;
                border-bottom: 1px solid var(--border-color);
                font-weight: 600;
            }

            .panel-header .badge {
                font-size: 11px;
                padding: 2px 8px;
                border-radius: 12px;
                font-weight: 500;
            }

            .badge-output {
                background-color: var(--accent-color);
                color: #000;
            }

            .badge-reference {
                background-color: var(--success-color);
                color: #000;
            }

            .panel-content {
                padding: 16px;
            }

            .question-section {
                margin-bottom: 16px;
            }

            .question-label {
                font-size: 12px;
                text-transform: uppercase;
                color: var(--text-muted);
                margin-bottom: 4px;
                letter-spacing: 0.5px;
            }

            .question-text {
                font-size: 14px;
                color: var(--text-color);
            }

            .answer-section {
                background-color: #2d3136;
                border-radius: 6px;
                padding: 12px;
                margin-top: 12px;
            }

            .response-text {
                font-size: 14px;
                white-space: pre-wrap;
                word-wrap: break-word;
            }

            /* Dash-delimited list styling - matches choice-item selected style */
            .response-list {
                list-style: none;
                padding: 0;
                margin: 0;
            }

            .response-list li {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px 10px;
                margin-bottom: 4px;
                background-color: rgba(129, 201, 149, 0.1);
                border-radius: 4px;
                border-left: 3px solid var(--success-color);
                font-size: 13px;
                font-weight: 500;
                line-height: 1.4;
            }

            .response-list li:last-child {
                margin-bottom: 0;
            }

            .response-list li::before {
                content: "âœ“";
                display: flex;
                align-items: center;
                justify-content: center;
                width: 16px;
                height: 16px;
                background-color: var(--success-color);
                color: #000;
                border-radius: 50%;
                font-size: 10px;
                font-weight: 600;
                flex-shrink: 0;
            }

            /* Compact list styling inside table cells */
            td .response-list li {
                padding: 4px 8px;
                margin-bottom: 3px;
                font-size: 12px;
                gap: 6px;
            }

            td .response-list li::before {
                width: 14px;
                height: 14px;
                font-size: 9px;
            }

            .choices-list {
                margin-top: 8px;
            }

            .choice-item {
                display: flex;
                align-items: flex-start;
                gap: 8px;
                padding: 8px;
                border-radius: 4px;
                margin-bottom: 4px;
            }

            .choice-item.selected {
                background-color: rgba(74, 222, 128, 0.1);
                border-left: 3px solid var(--success-color);
            }

            .choice-item.not-selected {
                opacity: 0.6;
            }

            .choice-indicator {
                width: 18px;
                height: 18px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                flex-shrink: 0;
            }

            .choice-indicator.selected {
                background-color: var(--success-color);
                color: #000;
            }

            .choice-indicator.not-selected {
                background-color: var(--border-color);
                color: var(--text-muted);
            }

            .choice-content {
                flex: 1;
            }

            .choice-label {
                font-weight: 500;
                font-size: 13px;
            }

            .choice-reasoning {
                font-size: 12px;
                color: var(--text-muted);
                margin-top: 4px;
            }

            .table-container {
                overflow-x: auto;
                margin-top: 12px;
                width: 100%;
            }

            .table-shape {
                display: inline-block;
                font-size: 10px;
                color: var(--text-muted);
                margin-bottom: 6px;
                padding: 3px 8px;
                background-color: rgba(138, 180, 248, 0.1);
                border: 1px solid rgba(138, 180, 248, 0.2);
                border-radius: 4px;
                font-family: "Monaco", "Menlo", monospace;
                letter-spacing: 0.3px;
            }

            table {
                width: 100%;
                min-width: max-content;
                border-collapse: collapse;
                font-size: 13px;
                table-layout: fixed;
            }

            th,
            td {
                padding: 10px 12px;
                text-align: left;
                border: 1px solid var(--border-color);
                min-width: 180px;
                max-width: 350px;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }

            th:first-child,
            td:first-child {
                min-width: 40px;
                max-width: 60px;
                width: 40px;
            }

            th {
                background-color: #2d3136;
                font-weight: 600;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.3px;
                color: var(--accent-color);
            }

            td {
                background-color: #22262b;
            }

            .diff-legend {
                display: flex;
                gap: 16px;
                font-size: 12px;
                margin-bottom: 12px;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .legend-color {
                width: 12px;
                height: 12px;
                border-radius: 2px;
            }

            .legend-color.match {
                background-color: var(--success-color);
            }

            .legend-color.diff {
                background-color: var(--error-color);
            }

            .legend-color.missing {
                background-color: var(--warning-color);
            }

            .diff-table td.match {
                background-color: rgba(74, 222, 128, 0.1);
            }

            .diff-table td.diff {
                background-color: var(--diff-removed-bg);
            }

            .diff-table td.missing {
                background-color: rgba(251, 191, 36, 0.1);
            }

            .diff-table td.extra {
                background-color: rgba(76, 201, 240, 0.1);
            }

            .cell-comparison {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .cell-output {
                color: var(--text-color);
            }

            .cell-reference {
                font-size: 11px;
                color: var(--text-muted);
                padding-top: 4px;
                border-top: 1px dashed var(--border-color);
            }

            .cell-reference::before {
                content: "Expected: ";
                color: var(--warning-color);
                font-weight: 500;
            }

            .stats-summary {
                display: flex;
                gap: 24px;
                padding: 12px 16px;
                background-color: #2d3136;
                border-radius: 6px;
                margin-bottom: 16px;
            }

            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .stat-value {
                font-size: 24px;
                font-weight: 700;
            }

            .stat-value.good {
                color: var(--success-color);
            }
            .stat-value.bad {
                color: var(--error-color);
            }
            .stat-value.neutral {
                color: var(--warning-color);
            }

            .stat-label {
                font-size: 11px;
                text-transform: uppercase;
                color: var(--text-muted);
                letter-spacing: 0.5px;
            }

            .side-by-side {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px;
            }

            @media (max-width: 900px) {
                .side-by-side {
                    grid-template-columns: 1fr;
                }
            }

            .loading {
                text-align: center;
                padding: 40px;
                color: var(--text-muted);
            }

            .metadata-section {
                margin-top: 16px;
                padding-top: 12px;
                border-top: 1px solid var(--border-color);
            }

            .metadata-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 8px;
            }

            .metadata-item {
                font-size: 12px;
            }

            .metadata-key {
                color: var(--text-muted);
            }

            .metadata-value {
                color: var(--text-color);
                font-family: monospace;
            }

            .json-fallback {
                background-color: #2d3136;
                border-radius: 6px;
                padding: 12px;
                overflow-x: auto;
                font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
                font-size: 12px;
                line-height: 1.6;
            }

            /* renderjson overrides for dark theme */
            .json-fallback .renderjson a {
                text-decoration: none;
                color: var(--accent-color);
            }

            .json-fallback .renderjson a:hover {
                color: #a8c7fa;
            }

            .json-fallback .disclosure {
                color: var(--accent-color);
                font-weight: bold;
                cursor: pointer;
                padding: 0 4px;
            }

            .json-fallback .string {
                color: #f9a825; /* orange/amber for strings */
            }

            .json-fallback .number {
                color: #8ab4f8; /* blue for numbers */
            }

            .json-fallback .boolean {
                color: #c4b5fd; /* purple for booleans */
            }

            .json-fallback .key {
                color: #4fc3f7; /* cyan for keys */
            }

            .json-fallback .null {
                color: var(--text-muted);
            }

            .json-fallback .syntax {
                color: var(--text-color);
            }

            .debug-panel {
                border: 2px solid #f0f !important;
            }

            /* Tool Call / PerPageAnswer styles */
            .tool-call-header {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 12px;
            }

            .tool-call-name {
                font-size: 12px;
                font-weight: 600;
                color: var(--accent-color);
                padding: 4px 10px;
                background-color: rgba(138, 180, 248, 0.15);
                border-radius: 4px;
                font-family: monospace;
            }

            .tool-call-id {
                font-size: 10px;
                color: var(--text-muted);
                font-family: monospace;
            }

            .per-page-answer {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .ppa-field {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .ppa-field-label {
                font-size: 10px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: var(--text-muted);
            }

            .ppa-field-value {
                font-size: 13px;
                line-height: 1.5;
                color: var(--text-color);
                white-space: pre-wrap;
                word-wrap: break-word;
            }

            .ppa-answer-box {
                background-color: rgba(129, 201, 149, 0.1);
                border-left: 3px solid var(--success-color);
                padding: 12px;
                border-radius: 0 6px 6px 0;
            }

            .ppa-reasoning-box {
                background-color: rgba(139, 92, 246, 0.1);
                border-left: 3px solid #a78bfa;
                padding: 12px;
                border-radius: 0 6px 6px 0;
            }

            .ppa-evidence-box {
                background-color: rgba(138, 180, 248, 0.1);
                border-left: 3px solid var(--accent-color);
                padding: 12px;
                border-radius: 0 6px 6px 0;
            }

            .ppa-meta-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 12px;
                padding: 12px;
                background-color: #2d3136;
                border-radius: 6px;
            }

            .ppa-meta-item {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .ppa-meta-label {
                font-size: 10px;
                color: var(--text-muted);
                text-transform: uppercase;
                letter-spacing: 0.3px;
            }

            .ppa-meta-value {
                font-size: 12px;
                color: var(--text-color);
                font-family: monospace;
                word-break: break-all;
            }

            .ppa-useful-badge {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                padding: 3px 8px;
                border-radius: 12px;
                font-size: 11px;
                font-weight: 600;
            }

            .ppa-useful-badge.useful {
                background-color: rgba(129, 201, 149, 0.2);
                color: var(--success-color);
            }

            .ppa-useful-badge.not-useful {
                background-color: rgba(242, 139, 130, 0.2);
                color: var(--error-color);
            }

            /* LLM Text Response / Markdown styles */
            .llm-response-meta {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                padding: 10px 14px;
                background-color: #2d3136;
                border-bottom: 1px solid var(--border-color);
                font-size: 11px;
            }

            .llm-meta-item {
                display: flex;
                align-items: center;
                gap: 6px;
                color: var(--text-muted);
            }

            .llm-meta-value {
                color: var(--text-color);
                font-family: monospace;
            }

            .markdown-content {
                padding: 16px;
                font-size: 14px;
                line-height: 1.6;
                color: var(--text-color);
            }

            .markdown-content h1,
            .markdown-content h2,
            .markdown-content h3,
            .markdown-content h4,
            .markdown-content h5,
            .markdown-content h6 {
                margin-top: 1.5em;
                margin-bottom: 0.5em;
                font-weight: 600;
                color: var(--text-color);
            }

            .markdown-content h1 {
                font-size: 1.5em;
            }
            .markdown-content h2 {
                font-size: 1.3em;
            }
            .markdown-content h3 {
                font-size: 1.15em;
            }
            .markdown-content h4 {
                font-size: 1em;
            }

            .markdown-content p {
                margin: 0.8em 0;
            }

            .markdown-content ul,
            .markdown-content ol {
                margin: 0.8em 0;
                padding-left: 1.5em;
            }

            .markdown-content li {
                margin: 0.3em 0;
            }

            .markdown-content code {
                background-color: rgba(138, 180, 248, 0.15);
                padding: 2px 6px;
                border-radius: 3px;
                font-family: "Monaco", "Menlo", monospace;
                font-size: 0.9em;
            }

            .markdown-content pre {
                background-color: #1a1d21;
                border: 1px solid var(--border-color);
                border-radius: 6px;
                padding: 12px;
                overflow-x: auto;
                margin: 1em 0;
            }

            .markdown-content pre code {
                background: none;
                padding: 0;
                font-size: 12px;
            }

            .markdown-content blockquote {
                border-left: 3px solid var(--accent-color);
                margin: 1em 0;
                padding: 0.5em 1em;
                background-color: rgba(138, 180, 248, 0.05);
                color: var(--text-muted);
            }

            .markdown-content table {
                border-collapse: collapse;
                width: auto;
                min-width: 0;
                margin: 1em 0;
                font-size: 13px;
                table-layout: auto;
            }

            .markdown-content th,
            .markdown-content td {
                border: 1px solid var(--border-color);
                padding: 8px 12px;
                text-align: left;
                min-width: 0;
                max-width: none;
                width: auto;
                white-space: normal;
            }

            .markdown-content th {
                background-color: #2d3136;
                font-weight: 600;
                white-space: nowrap;
            }

            .markdown-content hr {
                border: none;
                border-top: 1px solid var(--border-color);
                margin: 1.5em 0;
            }

            .markdown-content a {
                color: var(--accent-color);
                text-decoration: none;
            }

            .markdown-content a:hover {
                text-decoration: underline;
            }

            .markdown-content strong {
                font-weight: 600;
                color: var(--text-color);
            }

            .markdown-content em {
                font-style: italic;
            }

            .reasoning-table th {
                background-color: rgba(139, 92, 246, 0.25);
                color: #c4b5fd;
            }

            .reasoning-table td {
                background-color: rgba(139, 92, 246, 0.08);
                font-size: 12px;
                line-height: 1.4;
            }

            .table-section-label {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                margin-bottom: 8px;
                padding: 4px 10px;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .table-section-label.values {
                background-color: rgba(138, 180, 248, 0.2);
                color: #8ab4f8;
            }

            .table-section-label.reasoning {
                background-color: rgba(139, 92, 246, 0.2);
                color: #c4b5fd;
            }

            /* Tabs */
            .tabs {
                display: flex;
                gap: 0;
                border-bottom: 1px solid var(--border-color);
                margin-bottom: 0;
            }

            .tab {
                padding: 10px 20px;
                background: none;
                border: none;
                border-bottom: 2px solid transparent;
                cursor: pointer;
                font-size: 13px;
                font-weight: 500;
                color: var(--text-muted);
                transition: all 0.2s;
            }

            .tab:hover {
                color: var(--text-color);
                background-color: #2d3136;
            }

            .tab.active {
                color: var(--accent-color);
                border-bottom-color: var(--accent-color);
            }

            .tab-count {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                min-width: 18px;
                height: 18px;
                padding: 0 5px;
                margin-left: 6px;
                background-color: #3c4043;
                border-radius: 9px;
                font-size: 11px;
                font-weight: 600;
                color: var(--text-muted);
            }

            .tab.active .tab-count {
                background-color: rgba(138, 180, 248, 0.2);
                color: var(--accent-color);
            }

            .tab-content {
                display: none;
                padding: 16px;
            }

            .tab-content.active {
                display: block;
            }

            /* Source Documents */
            .source-doc {
                border: 1px solid var(--border-color);
                border-radius: 6px;
                margin-bottom: 12px;
                overflow: hidden;
            }

            .source-doc:last-child {
                margin-bottom: 0;
            }

            .source-doc-header {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 10px 14px;
                background-color: #2d3136;
                border-bottom: 1px solid var(--border-color);
                cursor: pointer;
            }

            .source-doc-header:hover {
                background-color: #363b41;
            }

            .source-doc-icon {
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                background-color: rgba(138, 180, 248, 0.2);
                border-radius: 6px;
                color: var(--accent-color);
                font-size: 14px;
            }

            .source-doc-meta {
                flex: 1;
                min-width: 0;
            }

            .source-doc-filename {
                font-weight: 600;
                font-size: 13px;
                color: var(--text-color);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .source-doc-details {
                display: flex;
                flex-wrap: wrap;
                gap: 8px 16px;
                font-size: 11px;
                color: var(--text-muted);
                margin-top: 4px;
            }

            .source-doc-detail {
                display: flex;
                align-items: center;
                gap: 4px;
                word-break: break-all;
            }

            .source-doc-toggle {
                color: var(--text-muted);
                font-size: 12px;
                transition: transform 0.2s;
            }

            .source-doc.expanded .source-doc-toggle {
                transform: rotate(180deg);
            }

            .view-pdf-btn {
                padding: 4px 8px;
                background-color: rgba(138, 180, 248, 0.2);
                border: 1px solid rgba(138, 180, 248, 0.3);
                border-radius: 4px;
                color: var(--accent-color);
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
                margin-right: 8px;
            }

            .view-pdf-btn:hover {
                background-color: rgba(138, 180, 248, 0.3);
                transform: scale(1.05);
            }

            .source-doc-content {
                display: none;
                padding: 14px;
                background-color: #22262b;
                font-size: 13px;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                max-height: 300px;
                overflow-y: auto;
            }

            .source-doc.expanded .source-doc-content {
                display: block;
            }

            .no-sources {
                text-align: center;
                padding: 40px 20px;
                color: var(--text-muted);
                font-size: 13px;
            }

            /* Split cell layout - value on left, reasoning on right */
            .split-cell {
                display: flex;
                flex-direction: column;
                gap: 0;
                min-height: 100%;
                margin: -10px -12px;
            }

            .split-cell-value {
                flex: 1;
                padding: 10px 12px;
                background-color: rgba(138, 180, 248, 0.06);
                word-wrap: break-word;
                overflow-wrap: break-word;
            }

            .split-cell-reasoning {
                padding: 8px 12px;
                font-size: 11px;
                color: var(--text-muted);
                line-height: 1.4;
                background-color: rgba(139, 92, 246, 0.06);
                border-top: 1px solid var(--border-color);
                word-wrap: break-word;
                overflow-wrap: break-word;
            }

            .split-cell-reasoning:empty {
                display: none;
            }

            /* Inline reference bubbles */
            .ref-bubble {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                min-width: 18px;
                height: 18px;
                padding: 0 5px;
                margin: 0 2px;
                background-color: var(--accent-color);
                color: #1a1d21;
                border-radius: 9px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.15s ease;
                vertical-align: middle;
            }

            .ref-bubble:hover {
                background-color: #a8c7fa;
                transform: scale(1.1);
            }

            .ref-bubble.invalid {
                background-color: var(--error-color);
                color: #1a1d21;
            }

            .ref-bubble.invalid:hover {
                background-color: #f5a9a3;
            }

            /* Source document index badge */
            .source-doc-index {
                display: flex;
                align-items: center;
                justify-content: center;
                min-width: 28px;
                height: 28px;
                padding: 0 8px;
                background-color: var(--accent-color);
                color: #1a1d21;
                border-radius: 14px;
                font-size: 12px;
                font-weight: 700;
                flex-shrink: 0;
            }

            /* Highlighted source when navigated to */
            .source-doc.highlighted {
                border-color: var(--accent-color);
                box-shadow: 0 0 0 2px rgba(138, 180, 248, 0.3);
            }

            .source-doc.highlighted .source-doc-header {
                background-color: rgba(138, 180, 248, 0.15);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="content">
                <div class="loading">Waiting for data from LangSmith...</div>
            </div>
            <div id="debug-container" style="display: none"></div>
        </div>

        <button
            id="debug-toggle"
            style="
                position: fixed;
                bottom: 10px;
                right: 10px;
                padding: 8px 12px;
                background: #2d3136;
                color: #9aa0a6;
                border: 1px solid #3c4043;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                z-index: 1000;
            "
        >
            Show Debug
        </button>

        <script>
            // Debug toggle functionality
            let debugVisible = false;
            document
                .getElementById("debug-toggle")
                .addEventListener("click", function () {
                    debugVisible = !debugVisible;
                    const debugContainer =
                        document.getElementById("debug-container");
                    debugContainer.style.display = debugVisible
                        ? "block"
                        : "none";
                    this.textContent = debugVisible
                        ? "Hide Debug"
                        : "Show Debug";
                    this.style.background = debugVisible
                        ? "#4a235a"
                        : "#2d3136";
                });

            // Store received data
            let outputData = null;
            let referenceData = null;
            let metadata = null;
            let rawMessage = null;

            // Extract tool calls from LLM API response structures
            // Supports: LangChain LLMResult, direct tool_calls arrays, etc.
            function extractToolCalls(data) {
                if (!data || typeof data !== "object") return null;

                // Direct tool_calls array
                if (
                    Array.isArray(data.tool_calls) &&
                    data.tool_calls.length > 0
                ) {
                    return data.tool_calls;
                }

                // LangChain LLMResult structure: generations[0][0].message.kwargs.tool_calls
                if (data.generations && Array.isArray(data.generations)) {
                    try {
                        const firstGen = data.generations[0];
                        if (Array.isArray(firstGen) && firstGen.length > 0) {
                            const message = firstGen[0]?.message;
                            const kwargs = message?.kwargs;
                            if (
                                kwargs?.tool_calls &&
                                Array.isArray(kwargs.tool_calls) &&
                                kwargs.tool_calls.length > 0
                            ) {
                                return kwargs.tool_calls;
                            }
                        }
                    } catch (e) {
                        // Continue to other extraction methods
                    }
                }

                // OpenAI-style: choices[0].message.tool_calls
                if (
                    data.choices &&
                    Array.isArray(data.choices) &&
                    data.choices.length > 0
                ) {
                    const toolCalls = data.choices[0]?.message?.tool_calls;
                    if (Array.isArray(toolCalls) && toolCalls.length > 0) {
                        return toolCalls;
                    }
                }

                return null;
            }

            // Find a specific tool call by name from extracted tool calls
            function findToolCallByName(toolCalls, name) {
                if (!toolCalls || !Array.isArray(toolCalls)) return null;
                return toolCalls.find(
                    (tc) => tc.name === name || tc.function?.name === name,
                );
            }

            // Get tool call args (handles different formats)
            function getToolCallArgs(toolCall) {
                if (!toolCall) return null;
                // LangChain format: args directly on object
                if (toolCall.args && typeof toolCall.args === "object") {
                    return toolCall.args;
                }
                // OpenAI format: function.arguments as JSON string
                if (toolCall.function?.arguments) {
                    try {
                        return JSON.parse(toolCall.function.arguments);
                    } catch (e) {
                        return null;
                    }
                }
                return null;
            }

            // Unwrap data if nested in an "output" key or LLM API response
            function unwrapData(data) {
                if (!data || typeof data !== "object") return data;

                // If data has an "output" key and it looks like the actual payload, unwrap it
                if (data.output && typeof data.output === "object") {
                    const nested = data.output;
                    const isTableResponse =
                        "column_headers" in nested ||
                        "rows" in nested ||
                        "reasoning" in nested ||
                        "question_text" in nested ||
                        "table_question_id" in nested;
                    const isEQAAnswer =
                        "response_text" in nested ||
                        "choices" in nested ||
                        "response_objects" in nested;

                    if (isTableResponse || isEQAAnswer) {
                        return nested;
                    }
                }

                // Check for LLM API response with tool calls
                const toolCalls = extractToolCalls(data);
                if (toolCalls && toolCalls.length > 0) {
                    // Return a wrapper that preserves both the original data and extracted tool calls
                    return {
                        _isLLMToolCallResponse: true,
                        _originalData: data,
                        _toolCalls: toolCalls,
                    };
                }

                // Check for LLM API response with text content (no tool calls)
                const textContent = extractLLMTextContent(data);
                if (textContent) {
                    return {
                        _isLLMTextResponse: true,
                        _originalData: data,
                        _textContent: textContent,
                    };
                }

                return data;
            }

            // Listen for messages from LangSmith
            window.addEventListener("message", (event) => {
                const message = event.data;

                if (!message || typeof message !== "object") return;

                rawMessage = message;

                if (message.type === "output") {
                    outputData = unwrapData(message.data);
                    metadata = message.metadata;
                } else if (message.type === "reference") {
                    referenceData = unwrapData(message.data);
                }

                renderContent();
            });

            function renderContent() {
                const contentContainer = document.getElementById("content");
                const debugContainer =
                    document.getElementById("debug-container");

                if (!outputData && !referenceData) {
                    return;
                }

                const dataType = detectDataType(outputData || referenceData);

                // Render main content
                let contentHtml = "";

                // Check for tool call types first
                if (dataType.startsWith("tool_call:")) {
                    const toolName = dataType.replace("tool_call:", "");
                    const registry = TOOL_CALL_REGISTRY[toolName];
                    if (registry && registry.render) {
                        contentHtml = registry.render(
                            outputData,
                            referenceData,
                            metadata,
                        );
                    } else {
                        contentHtml = renderToolCallGeneric(
                            outputData,
                            referenceData,
                            metadata,
                        );
                    }
                } else {
                    switch (dataType) {
                        case "table_response":
                            contentHtml = renderTableResponse(
                                outputData,
                                referenceData,
                                metadata,
                            );
                            break;
                        case "eqa_answer":
                            contentHtml = renderEQAAnswer(
                                outputData,
                                referenceData,
                                metadata,
                            );
                            break;
                        case "documents_list":
                            contentHtml = renderDocumentsList(
                                outputData,
                                referenceData,
                                metadata,
                            );
                            break;
                        case "tool_call_generic":
                            contentHtml = renderToolCallGeneric(
                                outputData,
                                referenceData,
                                metadata,
                            );
                            break;
                        case "llm_text_response":
                            contentHtml = renderLLMTextResponse(
                                outputData,
                                referenceData,
                                metadata,
                            );
                            break;
                        default:
                            contentHtml = renderGenericJson(
                                outputData,
                                referenceData,
                                metadata,
                            );
                    }
                }
                contentContainer.innerHTML = contentHtml;

                // Render debug panel
                debugContainer.innerHTML = `
                    <div class="panel debug-panel">
                        <div class="panel-header">
                            <span>DEBUG INFO</span>
                        </div>
                        <div class="panel-content">
                            <div><strong>Detected Type:</strong> ${dataType}</div>
                            <div><strong>Has outputData:</strong> ${!!outputData}</div>
                            <div><strong>Has referenceData:</strong> ${!!referenceData}</div>
                            <div><strong>outputData keys:</strong> ${outputData ? Object.keys(outputData).join(", ") : "N/A"}</div>
                            <div><strong>"column_headers" in outputData:</strong> ${outputData ? "column_headers" in outputData : "N/A"}</div>
                            <div><strong>"rows" in outputData:</strong> ${outputData ? "rows" in outputData : "N/A"}</div>
                            <div style="margin-top: 10px;"><strong>Raw message.data:</strong></div>
                            <pre style="font-size: 11px; max-height: 150px; overflow: auto; background: #1a1d21; padding: 8px; border-radius: 4px;">${escapeHtml(JSON.stringify(rawMessage?.data, null, 2))}</pre>
                            <div style="margin-top: 10px;"><strong>Unwrapped outputData:</strong></div>
                            <pre style="font-size: 11px; max-height: 150px; overflow: auto; background: #1a1d21; padding: 8px; border-radius: 4px;">${escapeHtml(JSON.stringify(outputData, null, 2))}</pre>
                        </div>
                    </div>
                `;
            }

            // Registry of known tool call types and their detection functions
            // Add new tool types here to extend support
            const TOOL_CALL_REGISTRY = {
                PerPageAnswer: {
                    detect: (args) =>
                        "answer" in args &&
                        "reasoning" in args &&
                        "chunk_uuid" in args,
                    render: renderPerPageAnswer,
                },
                // Add more tool types here as needed:
                // "OtherToolName": {
                //     detect: (args) => "some_field" in args,
                //     render: renderOtherTool
                // }
            };

            // Extract text content from LLM API response
            function extractLLMTextContent(data) {
                if (!data || typeof data !== "object") return null;

                // LangChain LLMResult: generations[0][0].text
                if (data.generations && Array.isArray(data.generations)) {
                    try {
                        const firstGen = data.generations[0];
                        if (Array.isArray(firstGen) && firstGen.length > 0) {
                            const text = firstGen[0]?.text;
                            if (
                                text &&
                                typeof text === "string" &&
                                text.trim().length > 0
                            ) {
                                return {
                                    text: text,
                                    model:
                                        data.llm_output?.model_name ||
                                        firstGen[0]?.generation_info
                                            ?.model_name ||
                                        "unknown",
                                    tokenUsage:
                                        data.llm_output?.token_usage || null,
                                    finishReason:
                                        firstGen[0]?.generation_info
                                            ?.finish_reason || null,
                                };
                            }
                        }
                    } catch (e) {
                        // Continue
                    }
                }

                // OpenAI-style: choices[0].message.content
                if (
                    data.choices &&
                    Array.isArray(data.choices) &&
                    data.choices.length > 0
                ) {
                    const content = data.choices[0]?.message?.content;
                    if (
                        content &&
                        typeof content === "string" &&
                        content.trim().length > 0
                    ) {
                        return {
                            text: content,
                            model: data.model || "unknown",
                            tokenUsage: data.usage || null,
                            finishReason:
                                data.choices[0]?.finish_reason || null,
                        };
                    }
                }

                return null;
            }

            function detectDataType(data) {
                if (!data) return "unknown";

                // Check for LLM text response wrapper
                if (data._isLLMTextResponse && data._textContent) {
                    return "llm_text_response";
                }

                // Check for LLM tool call response wrapper
                if (data._isLLMToolCallResponse && data._toolCalls) {
                    // Check each tool call against the registry
                    for (const toolCall of data._toolCalls) {
                        const toolName =
                            toolCall.name || toolCall.function?.name;
                        const args = getToolCallArgs(toolCall);

                        // First check by explicit name
                        if (toolName && TOOL_CALL_REGISTRY[toolName]) {
                            return `tool_call:${toolName}`;
                        }

                        // Then check by structure detection
                        for (const [registeredName, config] of Object.entries(
                            TOOL_CALL_REGISTRY,
                        )) {
                            if (args && config.detect(args)) {
                                return `tool_call:${registeredName}`;
                            }
                        }
                    }
                    // Has tool calls but no known renderer - show as tool_call_generic
                    return "tool_call_generic";
                }

                // Check for documents array (document list output)
                if (
                    "documents" in data &&
                    Array.isArray(data.documents) &&
                    data.documents.length > 0 &&
                    data.documents[0].page_content !== undefined
                ) {
                    return "documents_list";
                }

                if (
                    "column_headers" in data ||
                    ("rows" in data && Array.isArray(data.rows)) ||
                    ("reasoning" in data && Array.isArray(data.reasoning))
                ) {
                    return "table_response";
                }

                if (
                    "response_text" in data ||
                    ("choices" in data && Array.isArray(data.choices)) ||
                    "response_objects" in data
                ) {
                    return "eqa_answer";
                }

                return "unknown";
            }

            function renderTableResponse(output, reference, meta) {
                let html = "";

                if (meta?.inputs?.question || meta?.inputs?.table_question) {
                    const question =
                        meta.inputs.table_question || meta.inputs.question;
                    html += `
                    <div class="panel">
                        <div class="panel-header"><span>Question</span></div>
                        <div class="panel-content">
                            <div class="question-text">${escapeHtml(question.text || question.parent_question?.text || JSON.stringify(question))}</div>
                            ${question.cell_questions ? renderColumnQuestions(question.cell_questions) : ""}
                        </div>
                    </div>
                `;
                }

                if (output && reference) {
                    html += renderTableDiff(output, reference);
                } else if (output) {
                    html += renderSingleTable(output, "Output", "output");
                } else if (reference) {
                    html += renderSingleTable(
                        reference,
                        "Reference",
                        "reference",
                    );
                }

                return html;
            }

            function renderColumnQuestions(cellQuestions) {
                if (!cellQuestions || cellQuestions.length === 0) return "";
                let html =
                    '<div class="metadata-section"><div class="question-label">Column Definitions</div><div class="choices-list">';
                cellQuestions.forEach((q, idx) => {
                    html += `
                    <div class="choice-item">
                        <div class="choice-indicator not-selected">${idx}</div>
                        <div class="choice-content">
                            <div class="choice-label">${escapeHtml(q.text || "")}</div>
                            ${q.data_type ? `<div class="choice-reasoning">Type: ${escapeHtml(q.data_type)}</div>` : ""}
                        </div>
                    </div>
                `;
                });
                html += "</div></div>";
                return html;
            }

            function renderTableDiff(output, reference) {
                const stats = calculateTableDiffStats(output, reference);
                const hasReasoning =
                    hasReasoningData(output) || hasReasoningData(reference);
                const sourceDocuments = getSourceDocuments(output, reference);
                const outputRows = output.rows || [];
                const refRows = reference.rows || [];
                const outputHeaders = output.column_headers || [];
                const refHeaders = reference.column_headers || [];
                const rowCount = Math.max(outputRows.length, refRows.length);
                const colCount = Math.max(
                    outputHeaders.length,
                    refHeaders.length,
                );

                return `
                <div class="panel">
                    <div class="panel-header">
                        <span>Table Comparison</span>
                        <span class="badge badge-output">Output vs Reference</span>
                    </div>
                    <div class="tabs">
                        <button class="tab active" data-tab="answers">Answers</button>
                        <button class="tab" data-tab="sources">Sources<span class="tab-count">${sourceDocuments.length}</span></button>
                    </div>
                    <div class="tab-content active" data-tab-content="answers">
                        <div class="stats-summary">
                            <div class="stat-item">
                                <span class="stat-value good">${stats.matchingCells}</span>
                                <span class="stat-label">Matching</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value bad">${stats.differentCells}</span>
                                <span class="stat-label">Different</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value neutral">${stats.missingCells}</span>
                                <span class="stat-label">Missing</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value neutral">${stats.extraCells}</span>
                                <span class="stat-label">Extra</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value ${stats.accuracy >= 80 ? "good" : stats.accuracy >= 50 ? "neutral" : "bad"}">${stats.accuracy.toFixed(1)}%</span>
                                <span class="stat-label">Accuracy</span>
                            </div>
                        </div>
                        <div class="diff-legend">
                            <div class="legend-item"><div class="legend-color match"></div> Match</div>
                            <div class="legend-item"><div class="legend-color diff"></div> Different</div>
                            <div class="legend-item"><div class="legend-color missing"></div> Missing/Extra</div>
                        </div>
                        <div class="table-container">
                            <div class="table-shape">rows x columns: [${rowCount} x ${colCount}]</div>
                            ${renderMergedTable(output, reference, sourceDocuments.length)}
                        </div>
                    </div>
                    <div class="tab-content" data-tab-content="sources">
                        ${renderSourceDocuments(sourceDocuments)}
                    </div>
                </div>
            `;
            }

            function calculateTableDiffStats(output, reference) {
                let matchingCells = 0,
                    differentCells = 0,
                    missingCells = 0,
                    extraCells = 0;

                const outputRows = output.rows || [];
                const refRows = reference.rows || [];
                const maxRows = Math.max(outputRows.length, refRows.length);
                const maxCols = Math.max(
                    output.column_headers?.length || 0,
                    reference.column_headers?.length || 0,
                );

                for (let i = 0; i < maxRows; i++) {
                    const outRow = outputRows[i] || [];
                    const refRow = refRows[i] || [];

                    for (let j = 0; j < maxCols; j++) {
                        const outCell = outRow[j];
                        const refCell = refRow[j];

                        if (outCell === undefined && refCell !== undefined)
                            missingCells++;
                        else if (outCell !== undefined && refCell === undefined)
                            extraCells++;
                        else if (
                            normalizeValue(outCell) === normalizeValue(refCell)
                        )
                            matchingCells++;
                        else differentCells++;
                    }
                }

                const totalComparable = matchingCells + differentCells;
                const accuracy =
                    totalComparable > 0
                        ? (matchingCells / totalComparable) * 100
                        : 0;

                return {
                    matchingCells,
                    differentCells,
                    missingCells,
                    extraCells,
                    accuracy,
                };
            }

            function normalizeValue(val) {
                if (val === null || val === undefined) return "";
                return String(val).trim().toLowerCase();
            }

            function hasReasoningData(data) {
                if (!data || !data.reasoning) return false;
                const rows = data.reasoning || [];
                // Show reasoning table if the field exists and is an array with rows
                return Array.isArray(rows) && rows.length > 0;
            }

            function getSourceDocuments(output, reference) {
                const outputDocs = output?.source_documents || [];
                const refDocs = reference?.source_documents || [];
                // Combine and deduplicate by some identifier if needed
                return [...outputDocs, ...refDocs];
            }

            function renderSourceDocuments(documents) {
                if (!documents || documents.length === 0) {
                    return '<div class="no-sources">No source documents available</div>';
                }

                return documents
                    .map((doc, index) => {
                        const metadata = doc.metadata || {};
                        const pageContent = doc.page_content || "";
                        const fileName =
                            metadata.file_name ||
                            metadata.filename ||
                            metadata.source ||
                            "Unknown file";
                        const pageNumber =
                            metadata.page_number ||
                            metadata.page ||
                            metadata.page_idx ||
                            "-";
                        const fileId =
                            metadata.file_id ||
                            metadata.id ||
                            metadata.chunk_uuid ||
                            "";

                        return `
                        <div class="source-doc" data-doc-index="${index}" data-file-id="${escapeHtml(fileId)}" data-page="${pageNumber}" id="source-doc-${index}">
                            <div class="source-doc-header" onclick="toggleSourceDoc(${index})">
                                <div class="source-doc-index">${index + 1}</div>
                                <div class="source-doc-meta">
                                    <div class="source-doc-filename">${escapeHtml(fileName)}</div>
                                    <div class="source-doc-details">
                                        <span class="source-doc-detail">Page: ${escapeHtml(String(pageNumber))}</span>
                                        ${fileId ? `<span class="source-doc-detail">ID: ${escapeHtml(fileId)}</span>` : ""}
                                    </div>
                                </div>
                                ${fileId ? `<button class="view-pdf-btn" onclick="event.stopPropagation(); openPdfViewer('${escapeHtml(fileId)}', ${typeof pageNumber === "number" ? pageNumber : 1}, '${escapeHtml(fileName)}')" title="View PDF">ðŸ“„</button>` : ""}
                                <span class="source-doc-toggle">&#9660;</span>
                            </div>
                            <div class="source-doc-content">${escapeHtml(pageContent)}</div>
                        </div>
                    `;
                    })
                    .join("");
            }

            function toggleSourceDoc(index) {
                const doc = document.querySelector(
                    `.source-doc[data-doc-index="${index}"]`,
                );
                if (doc) {
                    doc.classList.toggle("expanded");
                }
            }

            // Open PDF viewer in Briink LangSmith Extension
            // Sends a message to the parent window (LangSmith) which the extension listens for
            function openPdfViewer(fileId, page, fileName) {
                if (!fileId) {
                    console.warn("No file ID provided for PDF viewer");
                    return;
                }

                // Post message to parent window for the Chrome extension to intercept
                window.parent.postMessage(
                    {
                        type: "BRIINK_SOURCE_CLICK",
                        payload: {
                            fileId: fileId,
                            page: page || 1,
                            fileName: fileName || "document.pdf",
                        },
                    },
                    "*",
                );

                console.log("PDF viewer requested for:", {
                    fileId,
                    page,
                    fileName,
                });
            }

            // Parse choice reasoning from a reasoning string that may contain <<Choice Label>> markers
            // Example: "<<Yes>> This is because... <<No>> This doesn't apply because..."
            function parseChoiceReasoningFromText(reasoningText, choices) {
                if (!reasoningText || !choices || choices.length === 0) {
                    return {};
                }

                const choiceReasonings = {};
                const labels = choices.map((c) => c.label).filter(Boolean);

                // Build regex pattern to match <<Label>> sections
                // Match <<Label>> followed by content until next <<Label>> or end of string
                for (let i = 0; i < labels.length; i++) {
                    const label = labels[i];
                    const escapedLabel = label.replace(
                        /[.*+?^${}()|[\]\\]/g,
                        "\\$&",
                    );

                    // Pattern: <<Label>> followed by content until next <<...>> or end
                    const pattern = new RegExp(
                        `<<${escapedLabel}>>\\s*([\\s\\S]*?)(?=<<[^>]+>>|$)`,
                        "i",
                    );
                    const match = reasoningText.match(pattern);

                    if (match && match[1]) {
                        choiceReasonings[label] = match[1].trim();
                    }
                }

                return choiceReasonings;
            }

            // Enrich choices with reasoning parsed from the main reasoning text
            function enrichChoicesWithReasoning(data) {
                if (!data || !data.choices || data.choices.length === 0) {
                    return data.choices || [];
                }

                const choices = data.choices;
                const reasoningText = data.reasoning || "";

                // If reasoning is a string (not an array like in TableResponse), parse it
                if (
                    typeof reasoningText === "string" &&
                    reasoningText.includes("<<")
                ) {
                    const parsedReasonings = parseChoiceReasoningFromText(
                        reasoningText,
                        choices,
                    );

                    return choices.map((choice) => {
                        // Only set reasoning if not already present
                        if (
                            !choice.reasoning &&
                            choice.label &&
                            parsedReasonings[choice.label]
                        ) {
                            return {
                                ...choice,
                                reasoning: parsedReasonings[choice.label],
                            };
                        }
                        return choice;
                    });
                }

                return choices;
            }

            // Store source document count for validation
            let currentSourceCount = 0;

            function processInlineReferences(text, sourceCount) {
                if (!text) return "";
                currentSourceCount = sourceCount;

                // First escape HTML
                const div = document.createElement("div");
                div.textContent = String(text);
                let escaped = div.innerHTML;

                // Then replace [^N^] patterns with clickable bubbles
                // Display uses 1-based index, but navigation uses 0-based index internally
                escaped = escaped.replace(/\[\^(\d+)\^\]/g, (match, num) => {
                    const index = parseInt(num, 10);
                    const displayIndex = index + 1; // 1-based for display
                    const isValid = index >= 0 && index < sourceCount;
                    const className = isValid
                        ? "ref-bubble"
                        : "ref-bubble invalid";
                    return `<span class="${className}" onclick="navigateToSource(${index}, ${sourceCount})" title="${isValid ? "Go to source " + displayIndex : "Invalid reference (out of bounds)"}">${displayIndex}</span>`;
                });

                return escaped;
            }

            // Format response text, detecting dash-delimited lists
            // Pattern: lines starting with "- " or "â€“ " separated by newlines
            function formatResponseText(text, sourceCount) {
                if (!text) return "";

                const str = String(text).trim();

                // Check if text looks like a dash-delimited list
                // All non-empty lines must start with dash (even single items)
                const lines = str.split(/\n/);
                const nonEmptyLines = lines.filter((l) => l.trim());
                const dashLines = lines.filter((line) =>
                    /^\s*[-â€“]\s+/.test(line.trim()),
                );

                if (
                    dashLines.length >= 1 &&
                    dashLines.length === nonEmptyLines.length
                ) {
                    // All non-empty lines are dash items - render as list
                    const items = lines
                        .map((line) => line.trim())
                        .filter((line) => line)
                        .map((line) => line.replace(/^[-â€“]\s+/, "").trim())
                        .filter((item) => item);

                    if (items.length > 0) {
                        const listItems = items
                            .map(
                                (item) =>
                                    `<li>${processInlineReferences(item, sourceCount)}</li>`,
                            )
                            .join("");
                        return `<ul class="response-list">${listItems}</ul>`;
                    }
                }

                // Not a list - use standard processing
                return processInlineReferences(text, sourceCount);
            }

            function navigateToSource(index, sourceCount) {
                // Check if index is valid
                if (index < 0 || index >= sourceCount) {
                    console.warn("Invalid source reference:", index);
                    return;
                }

                // Find the panel containing the clicked reference
                const panel = event.target.closest(".panel");
                if (!panel) return;

                // Switch to sources tab
                const sourcesTab = panel.querySelector('[data-tab="sources"]');
                if (sourcesTab) {
                    sourcesTab.click();
                }

                // Wait a bit for tab switch, then scroll to and highlight the source
                setTimeout(() => {
                    const sourceDoc = panel.querySelector(
                        `#source-doc-${index}`,
                    );
                    if (sourceDoc) {
                        // Remove previous highlights
                        panel
                            .querySelectorAll(".source-doc.highlighted")
                            .forEach((el) => {
                                el.classList.remove("highlighted");
                            });

                        // Highlight and expand the target
                        sourceDoc.classList.add("highlighted");
                        sourceDoc.classList.add("expanded");

                        // Scroll into view
                        sourceDoc.scrollIntoView({
                            behavior: "smooth",
                            block: "center",
                        });

                        // Remove highlight after a delay
                        setTimeout(() => {
                            sourceDoc.classList.remove("highlighted");
                        }, 3000);
                    }
                }, 100);
            }

            function renderValuesTable(output, reference, sourceCount) {
                const outputHeaders = output.column_headers || [];
                const refHeaders = reference.column_headers || [];
                const headers =
                    outputHeaders.length >= refHeaders.length
                        ? outputHeaders
                        : refHeaders;

                const outputRows = output.rows || [];
                const refRows = reference.rows || [];
                const maxRows = Math.max(outputRows.length, refRows.length);
                const srcCount = sourceCount || 0;

                let html = '<table class="diff-table"><thead><tr><th>#</th>';
                headers.forEach((h) => {
                    html += `<th>${escapeHtml(h)}</th>`;
                });
                html += "</tr></thead><tbody>";

                for (let i = 0; i < maxRows; i++) {
                    const outRow = outputRows[i] || [];
                    const refRow = refRows[i] || [];
                    html += `<tr><td>${i + 1}</td>`;

                    for (let j = 0; j < headers.length; j++) {
                        const outCell = outRow[j];
                        const refCell = refRow[j];
                        const cellClass = getCellDiffClass(outCell, refCell);

                        html += `<td class="${cellClass}">`;
                        if (cellClass === "match") {
                            html += `<span class="cell-output">${formatResponseText(outCell || "", srcCount)}</span>`;
                        } else if (cellClass === "diff") {
                            html += `<div class="cell-comparison"><span class="cell-output">${formatResponseText(outCell || "", srcCount)}</span><span class="cell-reference">${formatResponseText(refCell || "", srcCount)}</span></div>`;
                        } else if (cellClass === "missing") {
                            html += `<span class="cell-reference">${formatResponseText(refCell || "", srcCount)}</span>`;
                        } else {
                            html += `<span class="cell-output">${formatResponseText(outCell || "", srcCount)}</span>`;
                        }
                        html += "</td>";
                    }
                    html += "</tr>";
                }

                html += "</tbody></table>";
                return html;
            }

            function renderMergedTable(output, reference, sourceCount) {
                const outputHeaders = output.column_headers || [];
                const refHeaders = reference.column_headers || [];
                const headers =
                    outputHeaders.length >= refHeaders.length
                        ? outputHeaders
                        : refHeaders;

                const outputRows = output.rows || [];
                const refRows = reference.rows || [];
                const outputReasoningRows = output.reasoning || [];
                const refReasoningRows = reference.reasoning || [];
                const maxRows = Math.max(outputRows.length, refRows.length);
                const srcCount = sourceCount || 0;

                let html = '<table class="diff-table"><thead><tr><th>#</th>';
                headers.forEach((h) => {
                    html += `<th>${escapeHtml(h)}</th>`;
                });
                html += "</tr></thead><tbody>";

                for (let i = 0; i < maxRows; i++) {
                    const outRow = outputRows[i] || [];
                    const refRow = refRows[i] || [];
                    const outReasoningRow = outputReasoningRows[i] || [];
                    const refReasoningRow = refReasoningRows[i] || [];
                    html += `<tr><td>${i + 1}</td>`;

                    for (let j = 0; j < headers.length; j++) {
                        const outCell = outRow[j];
                        const refCell = refRow[j];
                        const outReasoning = outReasoningRow[j] || "";
                        const refReasoning = refReasoningRow[j] || "";
                        const cellClass = getCellDiffClass(outCell, refCell);

                        html += `<td class="${cellClass}">`;
                        html += `<div class="split-cell">`;

                        // Value part (left)
                        html += `<div class="split-cell-value">`;
                        if (cellClass === "match") {
                            html += formatResponseText(outCell || "", srcCount);
                        } else if (cellClass === "diff") {
                            html += `<div class="cell-comparison"><span class="cell-output">${formatResponseText(outCell || "", srcCount)}</span><span class="cell-reference">${formatResponseText(refCell || "", srcCount)}</span></div>`;
                        } else if (cellClass === "missing") {
                            html += `<span class="cell-reference">${formatResponseText(refCell || "", srcCount)}</span>`;
                        } else {
                            html += formatResponseText(outCell || "", srcCount);
                        }
                        html += `</div>`;

                        // Reasoning part (right)
                        html += `<div class="split-cell-reasoning">`;
                        if (outReasoning) {
                            html += processInlineReferences(
                                outReasoning,
                                srcCount,
                            );
                            if (
                                cellClass === "diff" &&
                                refReasoning &&
                                refReasoning !== outReasoning
                            ) {
                                html += `<div class="cell-reference" style="margin-top: 4px;">${processInlineReferences(refReasoning, srcCount)}</div>`;
                            }
                        } else if (refReasoning) {
                            html += `<span class="cell-reference">${processInlineReferences(refReasoning, srcCount)}</span>`;
                        }
                        html += `</div>`;

                        html += `</div></td>`;
                    }
                    html += "</tr>";
                }

                html += "</tbody></table>";
                return html;
            }

            function getCellDiffClass(outCell, refCell) {
                if (outCell === undefined && refCell !== undefined)
                    return "missing";
                if (outCell !== undefined && refCell === undefined)
                    return "extra";
                if (normalizeValue(outCell) === normalizeValue(refCell))
                    return "match";
                return "diff";
            }

            function renderReasoningTable(output, reference, sourceCount) {
                const outputHeaders = output.column_headers || [];
                const refHeaders = reference.column_headers || [];
                const headers =
                    outputHeaders.length >= refHeaders.length
                        ? outputHeaders
                        : refHeaders;

                const outputReasoningRows = output.reasoning || [];
                const refReasoningRows = reference.reasoning || [];
                const maxRows = Math.max(
                    outputReasoningRows.length,
                    refReasoningRows.length,
                );
                const srcCount = sourceCount || 0;

                let html =
                    '<table class="diff-table reasoning-table"><thead><tr><th>#</th>';
                headers.forEach((h) => {
                    html += `<th>${escapeHtml(h)}</th>`;
                });
                html += "</tr></thead><tbody>";

                for (let i = 0; i < maxRows; i++) {
                    const outRow = outputReasoningRows[i] || [];
                    const refRow = refReasoningRows[i] || [];
                    html += `<tr><td>${i + 1}</td>`;

                    for (let j = 0; j < headers.length; j++) {
                        const outReasoning = outRow[j];
                        const refReasoning = refRow[j];

                        // Use same cell values to determine diff class
                        const outputRows = output.rows || [];
                        const refRows = reference.rows || [];
                        const outCell = outputRows[i]
                            ? outputRows[i][j]
                            : undefined;
                        const refCell = refRows[i] ? refRows[i][j] : undefined;
                        const cellClass = getCellDiffClass(outCell, refCell);

                        html += `<td class="${cellClass}">`;
                        if (cellClass === "match" || cellClass === "diff") {
                            if (outReasoning) {
                                html += `<div class="cell-comparison"><span class="cell-output">${processInlineReferences(outReasoning, srcCount)}</span>`;
                                if (
                                    cellClass === "diff" &&
                                    refReasoning &&
                                    refReasoning !== outReasoning
                                ) {
                                    html += `<span class="cell-reference">${processInlineReferences(refReasoning, srcCount)}</span>`;
                                }
                                html += `</div>`;
                            } else {
                                html += `<span class="cell-output" style="color: var(--text-muted); font-style: italic;">No reasoning</span>`;
                            }
                        } else if (cellClass === "missing") {
                            html += `<span class="cell-reference">${processInlineReferences(refReasoning || "", srcCount)}</span>`;
                        } else {
                            html += `<span class="cell-output">${processInlineReferences(outReasoning || "", srcCount)}</span>`;
                        }
                        html += "</td>";
                    }
                    html += "</tr>";
                }

                html += "</tbody></table>";
                return html;
            }

            function renderSingleTable(data, title, type) {
                const badgeClass =
                    type === "output" ? "badge-output" : "badge-reference";
                const sourceDocuments = data.source_documents || [];
                const srcCount = sourceDocuments.length;
                const rowCount = (data.rows || []).length;
                const colCount = (data.column_headers || []).length;

                return `
                <div class="panel">
                    <div class="panel-header">
                        <span>Table ${title}</span>
                        <span class="badge ${badgeClass}">${type}</span>
                    </div>
                    <div class="tabs">
                        <button class="tab active" data-tab="answers">Answers</button>
                        <button class="tab" data-tab="sources">Sources<span class="tab-count">${sourceDocuments.length}</span></button>
                    </div>
                    <div class="tab-content active" data-tab-content="answers">
                        ${data.question_text ? `<div class="question-section"><div class="question-label">Question</div><div class="question-text">${escapeHtml(data.question_text)}</div></div>` : ""}
                        <div class="table-container">
                            <div class="table-shape">rows x columns: [${rowCount} x ${colCount}]</div>
                            ${renderSingleMergedTable(data, srcCount)}
                        </div>
                    </div>
                    <div class="tab-content" data-tab-content="sources">
                        ${renderSourceDocuments(sourceDocuments)}
                    </div>
                </div>
            `;
            }

            function renderSingleMergedTable(data, srcCount) {
                const headers = data.column_headers || [];
                const rows = data.rows || [];
                const reasoningRows = data.reasoning || [];

                let html = "<table><thead><tr><th>#</th>";
                headers.forEach((h) => {
                    html += `<th>${escapeHtml(h)}</th>`;
                });
                html += "</tr></thead><tbody>";

                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i] || [];
                    const reasoningRow = reasoningRows[i] || [];
                    html += `<tr><td>${i + 1}</td>`;

                    for (let j = 0; j < headers.length; j++) {
                        const cell = row[j] || "";
                        const reasoning = reasoningRow[j] || "";

                        html += `<td><div class="split-cell">`;
                        html += `<div class="split-cell-value">${formatResponseText(cell, srcCount)}</div>`;
                        html += `<div class="split-cell-reasoning">${reasoning ? processInlineReferences(reasoning, srcCount) : ""}</div>`;
                        html += `</div></td>`;
                    }
                    html += "</tr>";
                }

                html += "</tbody></table>";
                return html;
            }

            function renderEQAAnswer(output, reference, meta) {
                let html = "";

                if (meta?.inputs?.question) {
                    const question = meta.inputs.question;
                    html += `
                    <div class="panel">
                        <div class="panel-header">
                            <span>Question</span>
                            ${question.data_type ? `<span class="badge badge-output">${escapeHtml(question.data_type)}</span>` : ""}
                        </div>
                        <div class="panel-content">
                            <div class="question-text">${escapeHtml(question.text || "")}</div>
                            ${question.choices && question.choices.length > 0 ? renderQuestionChoices(question.choices) : ""}
                        </div>
                    </div>
                `;
                }

                if (output && reference) {
                    html += `<div class="side-by-side">`;
                    html += renderSingleEQAAnswer(output, "Output", "output");
                    html += renderSingleEQAAnswer(
                        reference,
                        "Reference",
                        "reference",
                    );
                    html += `</div>`;
                    html += renderEQAComparison(output, reference);
                } else if (output) {
                    html += renderSingleEQAAnswer(output, "Output", "output");
                } else if (reference) {
                    html += renderSingleEQAAnswer(
                        reference,
                        "Reference",
                        "reference",
                    );
                }

                return html;
            }

            function renderQuestionChoices(choices) {
                let html =
                    '<div class="metadata-section"><div class="question-label">Available Choices</div><div class="choices-list">';
                choices.forEach((choice) => {
                    html += `
                    <div class="choice-item">
                        <div class="choice-content">
                            <div class="choice-label">${escapeHtml(choice.label || "")}</div>
                            ${choice.description ? `<div class="choice-reasoning">${escapeHtml(choice.description)}</div>` : ""}
                        </div>
                    </div>
                `;
                });
                html += "</div></div>";
                return html;
            }

            function renderSingleEQAAnswer(data, title, type) {
                const badgeClass =
                    type === "output" ? "badge-output" : "badge-reference";
                const sourceDocuments = data.source_documents || [];
                const srcCount = sourceDocuments.length;

                let answerContent = "";

                if (data.response_text) {
                    answerContent += `<div class="answer-section"><div class="question-label">Response</div><div class="response-text">${formatResponseText(data.response_text, srcCount)}</div></div>`;
                }

                // For choice-based questions, reasoning may contain <<Choice Label>> markers
                // Only show raw reasoning section if it doesn't contain choice markers (will be shown per-choice instead)
                const hasChoiceMarkers =
                    data.reasoning &&
                    typeof data.reasoning === "string" &&
                    data.reasoning.includes("<<");
                if (data.reasoning && !hasChoiceMarkers) {
                    answerContent += `<div class="answer-section"><div class="question-label">Reasoning</div><div class="response-text">${processInlineReferences(data.reasoning, srcCount)}</div></div>`;
                }

                if (data.choices && data.choices.length > 0) {
                    // Enrich choices with parsed reasoning from main reasoning text
                    const enrichedChoices = enrichChoicesWithReasoning(data);

                    answerContent += `<div class="answer-section"><div class="question-label">Choices</div><div class="choices-list">`;
                    enrichedChoices.forEach((choice) => {
                        answerContent += `
                        <div class="choice-item ${choice.is_selected ? "selected" : "not-selected"}">
                            <div class="choice-indicator ${choice.is_selected ? "selected" : "not-selected"}">${choice.is_selected ? "&#10003;" : ""}</div>
                            <div class="choice-content">
                                <div class="choice-label">${escapeHtml(choice.label || "")}</div>
                                ${choice.reasoning ? `<div class="choice-reasoning">${processInlineReferences(choice.reasoning, srcCount)}</div>` : ""}
                            </div>
                        </div>
                    `;
                    });
                    answerContent += `</div></div>`;
                }

                if (
                    data.response_objects &&
                    Object.keys(data.response_objects).length > 0
                ) {
                    answerContent += renderResponseObjects(
                        data.response_objects,
                        srcCount,
                    );
                }

                return `
                <div class="panel">
                    <div class="panel-header">
                        <span>${title}</span>
                        <span class="badge ${badgeClass}">${type}</span>
                    </div>
                    <div class="tabs">
                        <button class="tab active" data-tab="answers">Answers</button>
                        <button class="tab" data-tab="sources">Sources<span class="tab-count">${sourceDocuments.length}</span></button>
                    </div>
                    <div class="tab-content active" data-tab-content="answers">
                        ${answerContent}
                    </div>
                    <div class="tab-content" data-tab-content="sources">
                        ${renderSourceDocuments(sourceDocuments)}
                    </div>
                </div>
            `;
            }

            function renderResponseObjects(responseObjects, sourceCount) {
                const srcCount = sourceCount || 0;
                let html =
                    '<div class="answer-section"><div class="question-label">Additional Data</div>';

                if (responseObjects.metrics) {
                    const metrics = responseObjects.metrics;
                    html += `<div class="metadata-grid">`;
                    if (metrics.full_string_answers) {
                        html += `<div class="metadata-item"><span class="metadata-key">Answer: </span><span class="metadata-value">${processInlineReferences(metrics.full_string_answers, srcCount)}</span></div>`;
                    }
                    if (
                        metrics.structured_data &&
                        metrics.structured_data.length > 0
                    ) {
                        metrics.structured_data.forEach((m) => {
                            html += `<div class="metadata-item"><span class="metadata-key">${escapeHtml(m.metric_name)}: </span><span class="metadata-value">${m.value} ${escapeHtml(m.unit)} ${m.time_period ? `(${escapeHtml(m.time_period)})` : ""}</span></div>`;
                        });
                    }
                    html += `</div>`;
                }

                if (responseObjects.gap_analysis) {
                    const ga = responseObjects.gap_analysis;
                    html += `<div class="metadata-item"><span class="metadata-key">Gap Analysis: </span><span class="metadata-value">${processInlineReferences(ga.tag, srcCount)}</span></div>`;
                }

                if (responseObjects.scoring) {
                    const scoring = responseObjects.scoring;
                    html += `<div class="metadata-item"><span class="metadata-key">Score: </span><span class="metadata-value">${escapeHtml(scoring.score)}</span></div>`;
                }

                html += "</div>";
                return html;
            }

            function renderEQAComparison(output, reference) {
                const outputText = normalizeValue(output.response_text);
                const refText = normalizeValue(reference.response_text);
                const textMatch = outputText === refText;

                const outputChoices = new Set(
                    (output.choices || [])
                        .filter((c) => c.is_selected)
                        .map((c) => normalizeValue(c.label)),
                );
                const refChoices = new Set(
                    (reference.choices || [])
                        .filter((c) => c.is_selected)
                        .map((c) => normalizeValue(c.label)),
                );

                let choiceMatch = true;
                if (outputChoices.size > 0 || refChoices.size > 0) {
                    choiceMatch =
                        outputChoices.size === refChoices.size &&
                        [...outputChoices].every((c) => refChoices.has(c));
                }

                const overallMatch = textMatch && choiceMatch;

                return `
                <div class="panel">
                    <div class="panel-header">
                        <span>Comparison Summary</span>
                        <span class="badge ${overallMatch ? "badge-reference" : "badge-output"}">${overallMatch ? "Match" : "Mismatch"}</span>
                    </div>
                    <div class="panel-content">
                        <div class="stats-summary">
                            <div class="stat-item">
                                <span class="stat-value ${textMatch ? "good" : "bad"}">${textMatch ? "&#10003;" : "&#10007;"}</span>
                                <span class="stat-label">Response Text</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value ${choiceMatch ? "good" : "bad"}">${choiceMatch ? "&#10003;" : "&#10007;"}</span>
                                <span class="stat-label">Choices</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            }

            function renderDocumentsList(output, reference, meta) {
                let html = "";

                // Get documents from output or reference
                const outputDocs = output?.documents || [];
                const refDocs = reference?.documents || [];

                if (outputDocs.length > 0) {
                    html += `
                    <div class="panel">
                        <div class="panel-header">
                            <span>Documents</span>
                            <span class="badge badge-output">${outputDocs.length} documents</span>
                        </div>
                        <div class="panel-content">
                            ${renderDocumentsListItems(outputDocs)}
                        </div>
                    </div>
                    `;
                }

                if (refDocs.length > 0) {
                    html += `
                    <div class="panel">
                        <div class="panel-header">
                            <span>Reference Documents</span>
                            <span class="badge badge-reference">${refDocs.length} documents</span>
                        </div>
                        <div class="panel-content">
                            ${renderDocumentsListItems(refDocs)}
                        </div>
                    </div>
                    `;
                }

                return html;
            }

            function renderDocumentsListItems(documents) {
                if (!documents || documents.length === 0) {
                    return '<div class="no-sources">No documents available</div>';
                }

                return documents
                    .map((doc, index) => {
                        const metadata = doc.metadata || {};
                        const pageContent = doc.page_content || "";
                        const fileName =
                            metadata.file_name ||
                            metadata.filename ||
                            metadata.source ||
                            "Unknown file";
                        const pageNumber =
                            metadata.page_number ||
                            metadata.page ||
                            metadata.page_idx ||
                            "-";
                        const fileId =
                            metadata.file_id ||
                            metadata.id ||
                            metadata.chunk_uuid ||
                            "";
                        const chunkId =
                            metadata.chunk_id !== undefined
                                ? metadata.chunk_id
                                : "-";
                        const characters = metadata.characters || "-";

                        return `
                        <div class="source-doc" data-doc-index="${index}" id="doc-list-${index}">
                            <div class="source-doc-header" onclick="toggleDocListItem(${index})">
                                <div class="source-doc-index">${index + 1}</div>
                                <div class="source-doc-meta">
                                    <div class="source-doc-filename">${escapeHtml(fileName)}</div>
                                    <div class="source-doc-details">
                                        <span class="source-doc-detail">Page: ${escapeHtml(String(pageNumber))}</span>
                                        <span class="source-doc-detail">Chunk: ${escapeHtml(String(chunkId))}</span>
                                        <span class="source-doc-detail">Chars: ${escapeHtml(String(characters))}</span>
                                        ${fileId ? `<span class="source-doc-detail">ID: ${escapeHtml(fileId)}</span>` : ""}
                                    </div>
                                </div>
                                <span class="source-doc-toggle">&#9660;</span>
                            </div>
                            <div class="source-doc-content">${escapeHtml(pageContent)}</div>
                        </div>
                    `;
                    })
                    .join("");
            }

            function toggleDocListItem(index) {
                const doc = document.querySelector(`#doc-list-${index}`);
                if (doc) {
                    doc.classList.toggle("expanded");
                }
            }

            // Render PerPageAnswer tool call
            function renderPerPageAnswer(output, reference, meta) {
                let html = "";

                const renderSinglePerPageAnswer = (data, title, type) => {
                    if (!data || !data._isLLMToolCallResponse) return "";

                    const toolCalls = data._toolCalls || [];
                    const badgeClass =
                        type === "output" ? "badge-output" : "badge-reference";

                    let panelHtml = `
                        <div class="panel">
                            <div class="panel-header">
                                <span>${title}</span>
                                <span class="badge ${badgeClass}">${type}</span>
                            </div>
                            <div class="panel-content">
                    `;

                    toolCalls.forEach((toolCall, idx) => {
                        const toolName =
                            toolCall.name ||
                            toolCall.function?.name ||
                            "Unknown";
                        const toolId = toolCall.id || "";
                        const args = getToolCallArgs(toolCall);

                        if (!args) return;

                        panelHtml += `
                            <div class="tool-call-header">
                                <span class="tool-call-name">${escapeHtml(toolName)}</span>
                                ${toolId ? `<span class="tool-call-id">${escapeHtml(toolId)}</span>` : ""}
                                <span class="ppa-useful-badge ${args.is_useful ? "useful" : "not-useful"}">
                                    ${args.is_useful ? "&#10003; Useful" : "&#10007; Not Useful"}
                                </span>
                            </div>
                            <div class="per-page-answer">
                        `;

                        // Answer
                        if (args.answer) {
                            panelHtml += `
                                <div class="ppa-field">
                                    <div class="ppa-field-label">Answer</div>
                                    <div class="ppa-answer-box">
                                        <div class="ppa-field-value">${escapeHtml(args.answer)}</div>
                                    </div>
                                </div>
                            `;
                        }

                        // Reasoning
                        if (args.reasoning) {
                            panelHtml += `
                                <div class="ppa-field">
                                    <div class="ppa-field-label">Reasoning</div>
                                    <div class="ppa-reasoning-box">
                                        <div class="ppa-field-value">${escapeHtml(args.reasoning)}</div>
                                    </div>
                                </div>
                            `;
                        }

                        // Evidence Snippets
                        if (args.evidence_snippets) {
                            const snippets = Array.isArray(
                                args.evidence_snippets,
                            )
                                ? args.evidence_snippets
                                : [args.evidence_snippets];

                            if (snippets.length > 0 && snippets[0]) {
                                panelHtml += `
                                    <div class="ppa-field">
                                        <div class="ppa-field-label">Evidence Snippets</div>
                                        <div class="ppa-evidence-box">
                                            <div class="ppa-field-value">${escapeHtml(snippets.join("\n\n---\n\n"))}</div>
                                        </div>
                                    </div>
                                `;
                            }
                        }

                        // Metadata grid
                        panelHtml += `<div class="ppa-meta-grid">`;

                        if (args.source_description) {
                            panelHtml += `
                                <div class="ppa-meta-item">
                                    <div class="ppa-meta-label">Source</div>
                                    <div class="ppa-meta-value">${escapeHtml(args.source_description)}</div>
                                </div>
                            `;
                        }

                        if (args.chunk_uuid) {
                            panelHtml += `
                                <div class="ppa-meta-item">
                                    <div class="ppa-meta-label">Chunk UUID</div>
                                    <div class="ppa-meta-value">${escapeHtml(args.chunk_uuid)}</div>
                                </div>
                            `;
                        }

                        if (args.entity_scope) {
                            panelHtml += `
                                <div class="ppa-meta-item">
                                    <div class="ppa-meta-label">Entity Scope</div>
                                    <div class="ppa-meta-value">${escapeHtml(args.entity_scope)}</div>
                                </div>
                            `;
                        }

                        if (args.reporting_period) {
                            panelHtml += `
                                <div class="ppa-meta-item">
                                    <div class="ppa-meta-label">Reporting Period</div>
                                    <div class="ppa-meta-value">${escapeHtml(args.reporting_period)}</div>
                                </div>
                            `;
                        }

                        panelHtml += `</div></div>`;

                        if (idx < toolCalls.length - 1) {
                            panelHtml += `<hr style="border: none; border-top: 1px solid var(--border-color); margin: 16px 0;">`;
                        }
                    });

                    panelHtml += `</div></div>`;
                    return panelHtml;
                };

                if (output) {
                    html += renderSinglePerPageAnswer(
                        output,
                        "Per-Page Answer",
                        "output",
                    );
                }

                if (reference) {
                    html += renderSinglePerPageAnswer(
                        reference,
                        "Reference",
                        "reference",
                    );
                }

                return html;
            }

            // Render generic tool calls (for unknown tool types)
            function renderToolCallGeneric(output, reference, meta) {
                let html = "";

                const renderSingleToolCall = (data, title, type) => {
                    if (!data || !data._isLLMToolCallResponse) return "";

                    const toolCalls = data._toolCalls || [];
                    const badgeClass =
                        type === "output" ? "badge-output" : "badge-reference";

                    let panelHtml = `
                        <div class="panel">
                            <div class="panel-header">
                                <span>${title}</span>
                                <span class="badge ${badgeClass}">${type}</span>
                            </div>
                            <div class="panel-content">
                    `;

                    toolCalls.forEach((toolCall, idx) => {
                        const toolName =
                            toolCall.name ||
                            toolCall.function?.name ||
                            "Unknown";
                        const toolId = toolCall.id || "";
                        const args = getToolCallArgs(toolCall);

                        panelHtml += `
                            <div class="tool-call-header">
                                <span class="tool-call-name">${escapeHtml(toolName)}</span>
                                ${toolId ? `<span class="tool-call-id">${escapeHtml(toolId)}</span>` : ""}
                            </div>
                        `;

                        // Render args as JSON
                        if (args) {
                            const containerId = `tool-args-${Math.random().toString(36).substr(2, 9)}`;
                            setTimeout(() => {
                                const container =
                                    document.getElementById(containerId);
                                if (container) {
                                    renderjson.set_show_to_level(2);
                                    renderjson.set_icons("+", "-");
                                    container.appendChild(renderjson(args));
                                }
                            }, 0);

                            panelHtml += `<div class="json-fallback" id="${containerId}"></div>`;
                        }

                        if (idx < toolCalls.length - 1) {
                            panelHtml += `<hr style="border: none; border-top: 1px solid var(--border-color); margin: 16px 0;">`;
                        }
                    });

                    panelHtml += `</div></div>`;
                    return panelHtml;
                };

                if (output) {
                    html += renderSingleToolCall(
                        output,
                        "Tool Call Output",
                        "output",
                    );
                }

                if (reference) {
                    html += renderSingleToolCall(
                        reference,
                        "Reference",
                        "reference",
                    );
                }

                return html;
            }

            // Simple markdown to HTML converter
            function parseMarkdown(text) {
                if (!text) return "";

                let html = escapeHtml(text);

                // Code blocks (must be first to avoid interference)
                html = html.replace(
                    /```(\w*)\n([\s\S]*?)```/g,
                    (match, lang, code) => {
                        return `<pre><code class="language-${lang}">${code.trim()}</code></pre>`;
                    },
                );

                // Inline code
                html = html.replace(/`([^`]+)`/g, "<code>$1</code>");

                // Headers
                html = html.replace(/^######\s+(.+)$/gm, "<h6>$1</h6>");
                html = html.replace(/^#####\s+(.+)$/gm, "<h5>$1</h5>");
                html = html.replace(/^####\s+(.+)$/gm, "<h4>$1</h4>");
                html = html.replace(/^###\s+(.+)$/gm, "<h3>$1</h3>");
                html = html.replace(/^##\s+(.+)$/gm, "<h2>$1</h2>");
                html = html.replace(/^#\s+(.+)$/gm, "<h1>$1</h1>");

                // Bold and italic
                html = html.replace(
                    /\*\*\*(.+?)\*\*\*/g,
                    "<strong><em>$1</em></strong>",
                );
                html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
                html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");

                // Blockquotes
                html = html.replace(
                    /^&gt;\s+(.+)$/gm,
                    "<blockquote>$1</blockquote>",
                );

                // Horizontal rules
                html = html.replace(/^---$/gm, "<hr>");
                html = html.replace(/^\*\*\*$/gm, "<hr>");

                // Tables - parse markdown tables properly
                html = html.replace(/(\|.+\|\n)+/g, (tableMatch) => {
                    const lines = tableMatch.trim().split("\n");
                    if (lines.length < 2) return tableMatch;

                    let tableHtml = "<table>";
                    let inBody = false;
                    let hasHeader = false;

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const cells = line
                            .split("|")
                            .slice(1, -1)
                            .map((c) => c.trim());

                        // Check if this is a separator row (| --- | --- |)
                        if (cells.every((c) => /^[-:]+$/.test(c))) {
                            // The previous row was the header
                            hasHeader = true;
                            tableHtml += "</thead><tbody>";
                            inBody = true;
                            continue;
                        }

                        if (!inBody && !hasHeader) {
                            // First row - assume it's header until we see separator
                            tableHtml += `<thead><tr>${cells.map((c) => `<th>${c}</th>`).join("")}</tr>`;
                        } else {
                            // Data rows
                            tableHtml += `<tr>${cells.map((c) => `<td>${c}</td>`).join("")}</tr>`;
                        }
                    }

                    if (!inBody) {
                        // No separator found, close thead and add empty tbody
                        tableHtml += "</thead><tbody>";
                    }
                    tableHtml += "</tbody></table>";
                    return tableHtml;
                });

                // Unordered lists
                html = html.replace(/^[-*]\s+(.+)$/gm, "<li>$1</li>");
                html = html.replace(/((?:<li>.*<\/li>\n?)+)/g, "<ul>$1</ul>");

                // Ordered lists
                html = html.replace(/^\d+\.\s+(.+)$/gm, "<li>$1</li>");

                // Links
                html = html.replace(
                    /\[([^\]]+)\]\(([^)]+)\)/g,
                    '<a href="$2" target="_blank">$1</a>',
                );

                // Paragraphs - wrap remaining text blocks
                html = html
                    .split("\n\n")
                    .map((block) => {
                        block = block.trim();
                        if (!block) return "";
                        // Don't wrap if already wrapped in HTML tags
                        if (
                            /^<(h[1-6]|ul|ol|li|table|tr|th|td|pre|blockquote|hr)/.test(
                                block,
                            )
                        ) {
                            return block;
                        }
                        return `<p>${block.replace(/\n/g, "<br>")}</p>`;
                    })
                    .join("\n");

                return html;
            }

            // Render LLM text response with markdown
            function renderLLMTextResponse(output, reference, meta) {
                let html = "";

                const renderSingleTextResponse = (data, title, type) => {
                    if (!data || !data._isLLMTextResponse || !data._textContent)
                        return "";

                    const textContent = data._textContent;
                    const badgeClass =
                        type === "output" ? "badge-output" : "badge-reference";

                    let metaHtml = '<div class="llm-response-meta">';

                    if (textContent.model && textContent.model !== "unknown") {
                        metaHtml += `<div class="llm-meta-item">Model: <span class="llm-meta-value">${escapeHtml(textContent.model)}</span></div>`;
                    }

                    if (textContent.finishReason) {
                        metaHtml += `<div class="llm-meta-item">Finish: <span class="llm-meta-value">${escapeHtml(textContent.finishReason)}</span></div>`;
                    }

                    if (textContent.tokenUsage) {
                        const usage = textContent.tokenUsage;
                        if (usage.total_tokens) {
                            metaHtml += `<div class="llm-meta-item">Tokens: <span class="llm-meta-value">${usage.prompt_tokens || 0} + ${usage.completion_tokens || 0} = ${usage.total_tokens}</span></div>`;
                        }
                    }

                    metaHtml += "</div>";

                    const markdownHtml = parseMarkdown(textContent.text);

                    return `
                        <div class="panel">
                            <div class="panel-header">
                                <span>${title}</span>
                                <span class="badge ${badgeClass}">${type}</span>
                            </div>
                            ${metaHtml}
                            <div class="markdown-content">
                                ${markdownHtml}
                            </div>
                        </div>
                    `;
                };

                if (output) {
                    html += renderSingleTextResponse(
                        output,
                        "LLM Response",
                        "output",
                    );
                }

                if (reference) {
                    html += renderSingleTextResponse(
                        reference,
                        "Reference",
                        "reference",
                    );
                }

                return html;
            }

            function renderGenericJson(output, reference, meta) {
                let html = "";

                // Configure renderjson
                renderjson.set_show_to_level(1);
                renderjson.set_icons("+", "-");

                if (output) {
                    const outputContainerId = `json-output-${Math.random().toString(36).substr(2, 9)}`;
                    setTimeout(() => {
                        const container =
                            document.getElementById(outputContainerId);
                        if (container)
                            container.appendChild(renderjson(output));
                    }, 0);

                    html += `
                    <div class="panel">
                        <div class="panel-header"><span>Output</span><span class="badge badge-output">output</span></div>
                        <div class="panel-content">
                            <div class="json-fallback" id="${outputContainerId}"></div>
                        </div>
                    </div>
                `;
                }

                if (reference) {
                    const refContainerId = `json-ref-${Math.random().toString(36).substr(2, 9)}`;
                    setTimeout(() => {
                        const container =
                            document.getElementById(refContainerId);
                        if (container)
                            container.appendChild(renderjson(reference));
                    }, 0);

                    html += `
                    <div class="panel">
                        <div class="panel-header"><span>Reference</span><span class="badge badge-reference">reference</span></div>
                        <div class="panel-content">
                            <div class="json-fallback" id="${refContainerId}"></div>
                        </div>
                    </div>
                `;
                }

                return html;
            }

            function escapeHtml(text) {
                if (text === null || text === undefined) return "";
                const div = document.createElement("div");
                div.textContent = String(text);
                return div.innerHTML;
            }

            // Tab switching - use event delegation
            document.addEventListener("click", function (e) {
                if (e.target.classList.contains("tab")) {
                    const tab = e.target;
                    const tabName = tab.getAttribute("data-tab");
                    const panel = tab.closest(".panel");

                    // Update active tab
                    panel
                        .querySelectorAll(".tab")
                        .forEach((t) => t.classList.remove("active"));
                    tab.classList.add("active");

                    // Update active content
                    panel
                        .querySelectorAll(".tab-content")
                        .forEach((c) => c.classList.remove("active"));
                    panel
                        .querySelector(`[data-tab-content="${tabName}"]`)
                        .classList.add("active");
                }
            });
        </script>
    </body>
</html>
